import { Reducer, Action } from 'redux';
import { AppThunkAction } from './index';

export interface MessagesState {
    messages: Message[];
    inputMessage: Message;
}

export interface Message {
    id: string;
    text: string;
    userName: string;
}

export interface AddAction {
    type: 'MESSAGE_ADD';
    newMessage: Message;
}

export interface AddedAction {
    type: 'MESSAGE_ADDED';
}

export interface ReceiveListAction {
    type: 'MESSAGE_RECEIVE_LIST';
    messages: Message[];
}

export interface RequestListAction {
    type: 'MESSAGE_REQUEST_LIST';
}

type KnownAction = MessageAddPipelineAction | ReceiveListAction | RequestListAction
type MessageAddPipelineAction = AddAction | AddedAction

//export const actionCreators = {
//    add: () => ({ type: 'MESSAGES_ADD' } as AddAction)
//}

export const actionCreators = {
    requestMessages: (): AppThunkAction<KnownAction, void> => (dispatch, getState) => {
        console.log('MessagesStore.actionCreators.requestMessages called')
        // Only load data if it's something we don't already have (and are not already loading)
        const appState = getState();
        if (appState && appState.messages) {
            dispatch({ type: 'MESSAGE_REQUEST_LIST' });

            return fetch(`message`, { cache: "no-cache" })
                .then(response => response.json() as Promise<Message[]>)
                .then(data => {
                    dispatch({ type: 'MESSAGE_RECEIVE_LIST', messages: data });
                });
        } else {
            return Promise.resolve();
        }
    },
    addMessage: (messageInput: Message): AppThunkAction<MessageAddPipelineAction, void> => (dispatch, getState) => {
        console.log('MessagesStore.actionCreators.addMessage called');
        console.log('messageInput1:' + JSON.stringify(messageInput));
        const appState = getState();
        if (appState && appState.messages) {
            console.log('messageInput2:' + JSON.stringify(messageInput));
            dispatch({ type: 'MESSAGE_ADD', newMessage: messageInput });
            return fetch('message', { method: 'POST', body: JSON.stringify(messageInput) })
                .then(data => data.json() as Promise<Message>)
                .then(data => {
                    dispatch({ type: 'MESSAGE_ADDED' });
                });
        } else {
            return Promise.resolve();
        }
    }
};

export const reducer: Reducer<Message[]> = (state: Message[] | undefined, incomingAction: Action): Message[] => {
    if (!state) {
        state = [];
    }

    const action = incomingAction as KnownAction;

    switch (action.type) {
        case 'MESSAGE_ADD':
            return [
                ...state,
                action.newMessage
            ];
        case 'MESSAGE_ADDED':
            return [...state];
        case 'MESSAGE_RECEIVE_LIST':
            return [...action.messages];
        case 'MESSAGE_REQUEST_LIST':
            return [...state];
        default:
            return state;
    };
}